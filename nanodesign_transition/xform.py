#!/usr/bin/env python
"""
This module is used for geometrically transforming portions of a DNA structure. 
"""
from math import pi,sin,cos,atan,radians
import numpy as np
import sys

class Xform(object):
    """ This class stores information for an affine transformation. 

        Attributes:
            rotation_angles (List[Float]): The list of three Euler angles in degrees used to create a 
                rotation matrix. 
            translation (NumPy 3x1 ndarray[float]): The transformation translation.
            center (NumPy 3x1 ndarray[float]): The transformation center of rotation.
            rotation_matrix (NumPy 3x3 ndarray[float]): The transformation rotation matrix.
    """
    def __init__(self):
        self.rotation_angles = []
        self.translation = np.array([0.0, 0.0, 0.0], dtype=float)
        self.center = np.array([0.0, 0.0, 0.0], dtype=float)
        self.rotation_matrix = np.identity(3)

    def add_rotation(self, rotation_angles):
        """ Add a rotation matrix to the transformation. 

            Arguments:
                rotation_angles (List[Float]): The list of three Euler angles in degrees used to create a rotation matrix. 

            The current rotation matrix is multiplied by a rotation matrix generated by three Euler angles.
        """
        self.rotation_angles.append(rotation_angles)
        R = self.rotation_from_angles(rotation_angles)
        self.rotation_matrix = np.dot(self.rotation_matrix, R)

    def set_translation(self, translation):
        """ Set the transformation translation. """
        self.translation[:] = translation

    def set_center(self, center):
        """ Set the transformation center of rotation. """
        self.center[:] = center

    def print_transformation(self):
        """ Print the current transformation. """
        print("[xform] --------- rotation matrix ---------")
        print("[xform] %8.2f %8.2f %8.2f" % (self.rotation_matrix[0,0], self.rotation_matrix[0,1], self.rotation_matrix[0,2]))
        print("[xform] %8.2f %8.2f %8.2f" % (self.rotation_matrix[1,0], self.rotation_matrix[1,1], self.rotation_matrix[1,2]))
        print("[xform] %8.2f %8.2f %8.2f" % (self.rotation_matrix[2,0], self.rotation_matrix[2,1], self.rotation_matrix[2,2]))
        print("[xform] --------- translation ---------")
        print("[xform] %8.2f %8.2f %8.2f" % (self.translation[0], self.translation[1], self.translation[2]))
        print("[xform] --------- center ---------")
        print("[xform] %8.2f %8.2f %8.2f" % (self.center[0], self.center[1], self.center[2]))

    def rotation_from_angles(self, angles):
        """ Create a 3x3 rotation matrix from three Euler angles. 

            Arguments:
                angles (List[Float]): The three Euler angles in degrees used to create the rotation matrix. 

            The rotation matrix R created is the multiplication of three rotation matrices 
            about the X, Y and Z axes: R = Rz * Ry * Rx.

            Returns the rotate matrix R (NumPy 3x3 ndarray[float]). 
        """
        R = np.identity(3)
        xr = radians(angles[0])
        yr = radians(angles[1])
        zr = radians(angles[2])
        sx = sin(xr)
        sy = sin(yr)
        sz = sin(zr)
        cx = cos(xr)
        cy = cos(yr)
        cz = cos(zr)
        R[0,0] =  cy*cz;             R[0,1] = -cy*sz;             R[0,2] =  sy
        R[1,0] =  sx*sy*cz + cx*sz;  R[1,1] = -sx*sy*sz + cx*cz;  R[1,2] = -sx*cy
        R[2,0] = -cx*sy*cz + sx*sz;  R[2,1] =  cx*sy*sz + sx*cz;  R[2,2] =  cx*cy
        return R
    #__def rotation_from_angles

    def rotation_about_axis(self, axis, angle):
        """ Create a 3x3 rotation matrix about an axis.

            Arguments:
                axis (String): The axis to rotate about given as 'x', 'y' or 'z'.
                angle (Float): The angle in degrees to rotate. 

            Returns the rotate matrix R (NumPy 3x3 ndarray[float]). 
        """
        R = np.identity(3)
        angle = radians(angle)
        sx = sin(angle)
        cx = cos(angle)
        if axis == 'x':
            R[1,1] = cx 
            R[1,2] = -sx
            R[2,1] = sx 
            R[2,2] = cx
        elif axis == 'y':
            R[0,0] = cx 
            R[0,2] = sx
            R[2,0] = -sx 
            R[2,2] = cx
        elif axis == 'z':
            R[0,0] = cx
            R[0,1] = -sx
            R[1,0] = sx
            R[1,1] = cx
        return R

    def rms_fit(self, points1, points2):
        """ Fit two sets of coordinates. 

            Arguments:
                points1 (List[NumPy 3x1 ndarray[float]): The first list of 3D points. 
                points2 (List[NumPy 3x1 ndarray[float]): The second list of 3D points. 

            Calculates the transformation that will translate and rotate points1 to points2 using the method 
            described in Kabsch (Acta Cryst. (1978) A34, 827-828).
        """ 
        # Calculate centers.
        num_points = len(points1)
        center1 = np.array([0.0,0.0,0.0], dtype=float)
        center2 = np.array([0.0,0.0,0.0], dtype=float)
        for i in xrange(0,num_points): 
            center1 += points1[i]
            center2 += points2[i]
        #__for i in xrange(0,num_points) 
        center1 /= num_points 
        center2 /= num_points 

        # Move points centers to origin.
        cpts1 = np.array(points1, dtype=float, copy=True)
        cpts2 = np.array(points2, dtype=float, copy=True)
        for k in xrange(0,num_points): 
           cpts1[k] = points1[k] -  center1
           cpts2[k] = points2[k] -  center2
        #__for k in xrange(0,num_points)

        # Calculate correlation matrix.
        M = np.dot(cpts1.T, cpts2)

        # Calculate SVD of correlation matrix.
        U, S, V = np.linalg.svd(M)

        # Calulate rotation matirx.
        R = np.dot(U, V)

        self.translation = center2 - center1 
        self.center = center1 
        self.rotation_matrix = R
    #__def rms_fit(self, points1, points2)

#__class Xform

class HelixGroupXform(object):
    """ This class stores information for a geometric transformation of a group of helices.

        Attributes:
            helices (List[DnaStructureHelix]): The list of helices to transform.
            transformation (Xform): The transformation used to transform the helices.
    """
    def __init__(self, helices, transformation):
        self.helices = helices
        self.transformation = transformation

#__class HelixGroupXform


