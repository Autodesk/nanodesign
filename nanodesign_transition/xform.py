#!/usr/bin/env python
"""
This module is used for geometrically transforming portions of a DNA structure. 
"""
from math import pi,sin,cos,atan,radians
import numpy as np
import sys

class Xform(object):
    """ This class stores information for an affine transformation. 

        Attributes:
            rotation_angles (List[Float]): The list of three Euler angles in degrees used to create a 
                rotation matrix. 
            translation (NumPy 3x1 ndarray[float]): The transformation translation.
            center (NumPy 3x1 ndarray[float]): The transformation center of rotation.
            rotation_matrix (NumPy 3x3 ndarray[float]): The transformation rotation matrix.
    """
    def __init__(self, rotation_angles=None, translation=[0.0,0.0,0.0], 
                       center=[0.0,0.0,0.0], rotation_matrix=None):
        """ Initialize a transformation.

            Arguments:
                rotation_angles (List[Float], optional): The list of three Euler angles in degrees used to create a rotation matrix. 
                translation (List[Float], optional): A list containing the x,y,z offsets for the translation.
                center (List[Float], optional): A list containing the x,y,z offsets for the center point for any rotation.
                rotation_matrix (NumPy 3x3 ndarray[float], optional): A 3x3 rotation matrix, stored as a 3x3 numpy.ndarray.

            If you pass both a rotation_matrix paramater and a rotation_angles parameter, the rotation matrix will first be set, and then the rotation angles applied as if calling add_rotation.
        """
        self.rotation_angles = []
        self.translation = np.array( translation, dtype=float)
        self.center = np.array( center , dtype=float)
        if rotation_matrix is not None:
            self.rotation_matrix = rotation_matrix
        else:
            self.rotation_matrix = np.identity(3)

        if rotation_angles is not None:
            self.add_rotation( rotation_angles )

    def add_rotation(self, rotation_angles):
        """ Add a rotation matrix to the transformation. 

            Arguments:
                rotation_angles (List[Float]): The list of three Euler angles in degrees used to create a rotation matrix. 

            The current rotation matrix is multiplied by a rotation matrix generated by three Euler angles.
        """
        self.rotation_angles.append(rotation_angles)
        R = self.rotation_from_angles(rotation_angles)
        self.rotation_matrix = np.dot(self.rotation_matrix, R)

    def set_translation(self, translation):
        """ Set the transformation translation. """
        self.translation[:] = translation

    def set_center(self, center):
        """ Set the transformation center of rotation. """
        self.center[:] = center

    def print_transformation(self):
        """ Print the current transformation. """
        print("[xform] --------- rotation matrix ---------")
        print("[xform] %8.2f %8.2f %8.2f" % (self.rotation_matrix[0,0], self.rotation_matrix[0,1], self.rotation_matrix[0,2]))
        print("[xform] %8.2f %8.2f %8.2f" % (self.rotation_matrix[1,0], self.rotation_matrix[1,1], self.rotation_matrix[1,2]))
        print("[xform] %8.2f %8.2f %8.2f" % (self.rotation_matrix[2,0], self.rotation_matrix[2,1], self.rotation_matrix[2,2]))
        print("[xform] --------- translation ---------")
        print("[xform] %8.2f %8.2f %8.2f" % (self.translation[0], self.translation[1], self.translation[2]))
        print("[xform] --------- center ---------")
        print("[xform] %8.2f %8.2f %8.2f" % (self.center[0], self.center[1], self.center[2]))

    def rotation_from_angles(self, angles):
        """ Create a 3x3 rotation matrix from three Euler angles. 

            Arguments:
                angles (List[Float]): The three Euler angles in degrees used to create the rotation matrix. 

            The rotation matrix R created is the multiplication of three rotation matrices 
            about the X, Y and Z axes: R = Rz * Ry * Rx.

            Returns the rotate matrix R (NumPy 3x3 ndarray[float]). 
        """
        R = np.identity(3)
        xr = radians(angles[0])
        yr = radians(angles[1])
        zr = radians(angles[2])
        sx = sin(xr)
        sy = sin(yr)
        sz = sin(zr)
        cx = cos(xr)
        cy = cos(yr)
        cz = cos(zr)
        R[0,0] =  cy*cz;             R[0,1] = -cy*sz;             R[0,2] =  sy
        R[1,0] =  sx*sy*cz + cx*sz;  R[1,1] = -sx*sy*sz + cx*cz;  R[1,2] = -sx*cy
        R[2,0] = -cx*sy*cz + sx*sz;  R[2,1] =  cx*sy*sz + sx*cz;  R[2,2] =  cx*cy
        return R
    #__def rotation_from_angles

    def rotation_about_axis(self, axis, angle):
        """ Create a 3x3 rotation matrix about an axis.

            Arguments:
                axis (String): The axis to rotate about given as 'x', 'y' or 'z'.
                angle (Float): The angle in degrees to rotate. 

            Returns the rotate matrix R (NumPy 3x3 ndarray[float]). 
        """
        R = np.identity(3)
        angle = radians(angle)
        sx = sin(angle)
        cx = cos(angle)
        if axis == 'x':
            R[1,1] = cx 
            R[1,2] = -sx
            R[2,1] = sx 
            R[2,2] = cx
        elif axis == 'y':
            R[0,0] = cx 
            R[0,2] = sx
            R[2,0] = -sx 
            R[2,2] = cx
        elif axis == 'z':
            R[0,0] = cx
            R[0,1] = -sx
            R[1,0] = sx
            R[1,1] = cx
        return R

    def rms_fit(self, points1, points2):
        """ Fit two sets of coordinates. 

            Arguments:
                points1 (List[NumPy 3x1 ndarray[float]): The first list of 3D points. 
                points2 (List[NumPy 3x1 ndarray[float]): The second list of 3D points. 

            Calculates the transformation that will translate and rotate points1 to points2 using the method 
            described in Kabsch (Acta Cryst. (1978) A34, 827-828).
        """ 
        # Calculate centers.
        num_points = len(points1)
        center1 = np.array([0.0,0.0,0.0], dtype=float)
        center2 = np.array([0.0,0.0,0.0], dtype=float)
        for i in xrange(0,num_points): 
            center1 += points1[i]
            center2 += points2[i]
        #__for i in xrange(0,num_points) 
        center1 /= num_points 
        center2 /= num_points 

        # Move points centers to origin.
        cpts1 = np.array(points1, dtype=float, copy=True)
        cpts2 = np.array(points2, dtype=float, copy=True)
        for k in xrange(0,num_points): 
           cpts1[k] = points1[k] -  center1
           cpts2[k] = points2[k] -  center2
        #__for k in xrange(0,num_points)

        # Calculate correlation matrix.
        M = np.dot(cpts1.T, cpts2)

        # Calculate SVD of correlation matrix.
        U, S, V = np.linalg.svd(M)

        # Calulate rotation matirx.
        R = np.dot(U, V)

        self.translation = center2 - center1 
        self.center = center1 
        self.rotation_matrix = R
    #__def rms_fit(self, points1, points2)

#__class Xform


# TODO: We have left this class in as a basic storage container due to possible
# future needs. This should probably be revisited once we've worked on more
# algorithms that generate structure configurations from the topology.
class HelixGroupXform(object):
    """ This class stores information for a geometric transformation of a group of helices.

        Attributes:
            helices (List[DnaStructureHelix]): The list of helices to transform.
            transformation (Xform): The transformation used to transform the helices.
    """
    def __init__(self, helices, transformation):
        self.helices = helices
        self.transformation = transformation

#__class HelixGroupXform


def apply_helix_xforms(helix_group_xforms):
    """ Apply helix group transformations.

        Arguments:
            helix_group_xforms (List[HelixGroupXform]): The list of helix group transforms.

        The geometry for the list of helices for each group are rotated and translated together 
        by the given transformation. 
    """
    for helix_group in helix_group_xforms:
        # Get the center of the helix group.
        group_center = np.array([0.0,0.0,0.0], dtype=float)
        for helix in helix_group.helices:
            helix_center = helix.get_center()
            group_center += helix_center 
        #__for helix_id in helix_group.helices
        group_center /= len(helix_group.helices)
        helix_group.transformation.set_center(group_center)
 
        # Transform helices geometry.
        for helix in helix_group.helices:
            helix.apply_xform(helix_group.transformation)
        #__for helix_id in helix_group_xforms.helices:
    #__for helix_group in helix_group_xforms

#__def apply_helix_xforms


def xform_from_connectors(connector_strands, helix_ids, helix_distance, xform):
    """ Create a transformation to rotate and translate a group of helices so that
        distance crossovers (connections) align.

        Arguments:
            connector_strands (List[DnaStrand]): The list of strands that contain connections. 
            helix_ids (List[int]): The list of helix IDs to transform.
            xform (Xform): The transformation to set the rotation and translation used to 
                align the crossovers.

        This is an attempt to automatically generate a 3D structure from distanct scaffold
        crossovers used to assemble groups of helices. The algorithm builds two lists of 
        points for the scaffold connections and attempts to align them. This can typically produce 
        a transformation that only translates the two sections together but does not oriented them,  
        the relative rotation of two components created by excluded volume interactions. 
    """
    # Create a set of helix IDs to include in the transformation.
    helix_set = set()
    for id in helix_ids:
        helix_set.add(id)

    # Create the points lists for the connections. 
    max_dist = 2.0*helix_distance
    points1 = []
    points1_map = set()
    points2 = []
    points2_map = set()
    for strand in connector_strands:
        tour = strand.tour 
        for i in xrange(0,len(tour)-1):
            base1 = tour[i]
            pt1 = base1.coordinates
            base2 = tour[i+1]
            pt2 = base2.coordinates
            dist = np.linalg.norm(pt1 - pt2)
            if dist > max_dist:
                if (base1.h,base1.p) not in points1_map:
                    points1_map.add((base1.h,base1.p))
                    if base1.h in helix_set:
                        points1.append(pt1)
                    else:
                        points2.append(pt1)
                #__if (base1.h,base1.p) not in points1_map

                if (base2.h,base2.p) not in points2_map:
                    points2_map.add((base2.h,base2.p))

                    if base2.h in helix_set:
                        points1.append(pt2)
                    else:
                        points2.append(pt2)
                #__if (base2.h,base2.p) not in points2_map:
        #__for i in xrange(0,len(tour)-1)
    #__for strand in connector_strands

    # Set the transformation that fits points1 to points2.
    xform.rms_fit(points1, points2)
#__def xform_from_connectors
